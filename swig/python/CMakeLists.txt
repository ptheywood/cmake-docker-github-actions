# Signifcant portions of this are from https://github.com/FLAMEGPU/FLAMEGPU2, MIT license

cmake_minimum_required(VERSION VERSION 3.18 FATAL_ERROR)

# ------------------------------- @todo cmake/version.cmake
# These would belong in cmake/version.cmake in the main repo.
# @todo - get the version info from the header?
set(CDGA_VERSION_PYTHON_PUBLIC "0.0.1")
# Compute the local version, if requested.
set(CDGA_VERSION_PYTHON_LOCAL "${CDGA_VERSION_PYTHON_PUBLIC}")
# @todo - if FindCUDAToolkit is used, this could be massively simplified.
string(REPLACE "." ";" CUDA_VERSION_LIST ${CMAKE_CUDA_COMPILER_VERSION})
list(GET CUDA_VERSION_LIST 0 CUDA_VERSION_MAJOR)
list(GET CUDA_VERSION_LIST 1 CUDA_VERSION_MINOR)
set(CDGA_VERSION_PYTHON_LOCAL_SUFFIX "cuda${CUDA_VERSION_MAJOR}${CUDA_VERSION_MINOR}")
unset(CUDA_VERSION_LIST)
unset(CUDA_VERSION_MAJOR)
unset(CUDA_VERSION_MINOR)
if(NOT CDGA_VERSION_PYTHON_LOCAL_SUFFIX STREQUAL "")
  set(CDGA_VERSION_PYTHON_LOCAL "${CDGA_VERSION_PYTHON_LOCAL}+${CDGA_VERSION_PYTHON_LOCAL_SUFFIX}")
endif()
unset(CDGA_VERSION_PYTHON_LOCAL_SUFFIX)

# if the cmake option to embed local version is enabeld, do it.
set(CDGA_VERSION_PYTHON ${CDGA_VERSION_PYTHON_PUBLIC})
if(BUILD_SWIG_PYTHON_LOCALVERSION)
  set(CDGA_VERSION_PYTHON ${CDGA_VERSION_PYTHON_LOCAL})
endif()
# ---------------------------------------

get_filename_component(ROOT ${CMAKE_CURRENT_LIST_DIR}/../.. REALPATH)

find_package(CUDAToolkit REQUIRED) # CMake >= 3.17

# Set the python module name, i.e. import <PYTHON_MODULE_NAME>
set(PYTHON_MODULE_NAME pycdga)
# Calcuulate the distribution name, for nameing wheels / python packages. This is subject to change.
set(PYTHON_DISTRIBUTION_NAME ${PYTHON_MODULE_NAME})
# Visualisation is enabled  
if(VISUALISATION)
  set(PYTHON_DISTRIBUTION_NAME ${PYTHON_DISTRIBUTION_NAME}-visualisation)
endif()
# @todo - Embed seatbelts/Debug status?

# Set the output directory where the wheel etc should be placed.
# CMAKE 3.20 is required for byproducts contianing $<CONFIG> (i.e. multiconfig generators.) Workaround by only setting if supported, or usiing CMAKE_BUILD_TYPE for non-multi-generators.
# This is required for msvc multi-generator usage. For older cmake and non-mulit-config generators CMAKE_BUILD_TYPE can be used instead.
SET(PYTHON_LIB_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib/$<CONFIG>/python)
SET(PYTHON_LIB_OUTPUT_DIRECTORY_BYPRODUCTS TRUE)
if(${CMAKE_VERSION} VERSION_LESS "3.20")
  if(NOT ${GENERATOR_IS_MULTI_CONFIG})
    SET(PYTHON_LIB_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}/python)
  else()
    SET(PYTHON_LIB_OUTPUT_DIRECTORY_BYPRODUCTS FALSE)
  endif()
endif()
# Python library temp directory (for autogenerated swig files etc.)
SET(PYTHON_LIB_TEMP_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# set input file name
SET(SWIG_INPUT_FILE_NAME cdga)


#########################################
## Swig input processing and building  ##
#########################################

# setup properties of swig input file
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY CPLUSPLUS ON)
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY SWIG_MODULE_NAME ${PYTHON_MODULE_NAME})
set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY SWIG_FLAGS "-threads")
#set_property(SOURCE ${SWIG_INPUT_FILE_NAME}.i PROPERTY SWIG_FLAGS "-builtin")

# Add swig module
swig_add_library(${PYTHON_MODULE_NAME}
	TYPE SHARED
	#TYPE STATIC
	LANGUAGE python 
	OUTPUT_DIR ${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}
	SOURCES ${SWIG_INPUT_FILE_NAME}.i)

# configure wrapper code to build with cuda compiler
set_source_files_properties(${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}/${SWIG_INPUT_FILE_NAME}PYTHON_wrap.cxx PROPERTIES LANGUAGE CUDA)

# use the target include directories
set_property(TARGET ${PYTHON_MODULE_NAME} PROPERTY SWIG_USE_TARGET_INCLUDE_DIRECTORIES ON)
# needs to have RDC enable for the project
# set_property(TARGET ${PYTHON_MODULE_NAME} PROPERTY CUDA_SEPARABLE_COMPILATION ON)
# Build with the SWIG pre-processor macro enabled
set_property(TARGET ${PYTHON_MODULE_NAME} APPEND PROPERTY SWIG_GENERATED_COMPILE_DEFINITIONS "SWIG")

# Suppress warnings during compilation of SWIG generated PYTHON_wrap.cxx
# set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} -Xcudafe --diag_suppress=\"declared_but_not_referenced\"")
# set bigobj property for windows compiler (needed due to the sheer size of the generated swig file: https://www.reddit.com/r/AbsoluteUnits/)
# if(MSVC)
# 	set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} -Xcompiler /bigobj")
# endif()
# set include directories for module build
target_include_directories(${PYTHON_MODULE_NAME}
  PRIVATE
  ${Python3_INCLUDE_DIRS}
)


# Block windows.h min and max defines.
if(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    set_property(TARGET ${PYTHON_MODULE_NAME} APPEND PROPERTY SWIG_COMPILE_DEFINITIONS NOMINMAX)
    set_property(TARGET ${PYTHON_MODULE_NAME} APPEND PROPERTY SWIG_GENERATED_COMPILE_DEFINITIONS NOMINMAX)
endif()


target_link_libraries(${PYTHON_MODULE_NAME} PRIVATE cdga)
# These are inherrited from cdga
# target_link_libraries(${PYTHON_MODULE_NAME} PUBLIC CUDA::cudart)
# target_link_libraries(${PYTHON_MODULE_NAME} PUBLIC CUDA::cuda_driver)
if(MSVC)
  target_link_libraries(${PYTHON_MODULE_NAME} PRIVATE ${Python3_LIBRARIES})
endif()



#######################
## Python Packaging  ##
#######################
# Not needed, no RTC

# cleanup the flamegpu include file paths, so they're relative (begin `include/`) and seperated by `", "`
# foreach(FLAMEGPU_INC_FILE IN LISTS FLAMEGPU_INCLUDE)
#   file(RELATIVE_PATH FLAMEGPU_INC_FILE_CLEAN "${ROOT}" "${FLAMEGPU_INC_FILE}")
#   set(FLAMEGPU_INCLUDE_CLEAN "${FLAMEGPU_INCLUDE_CLEAN}'${FLAMEGPU_INC_FILE_CLEAN}', ")
# endforeach()


# Build a list of OS specific python package_data entries.
# set(FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC "")
# if(WIN32)
#   # @todo - See if there is a dynamic way to achieve this through target properties?  
#   set(FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC "${FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC}'glew32.dll', 'SDL2.dll', 'DevIL.dll'")
# endif()


# Get the cuda major and minor versions as required for setup.py. There is no easy cmake way to access this that is supported across multiple CMake versions..
string(REPLACE "." ";" CMAKE_CUDA_COMPILER_VERSION_LIST ${CMAKE_CUDA_COMPILER_VERSION})
list(GET CMAKE_CUDA_COMPILER_VERSION_LIST 0 CMAKE_CUDA_COMPILER_VERSION_MAJOR)
list(GET CMAKE_CUDA_COMPILER_VERSION_LIST 1 CMAKE_CUDA_COMPILER_VERSION_MINOR)


# configure the python setup.py and __init__.py files for packaging and output to the final lib output folder
configure_file(
	setup.py.in
	${PYTHON_LIB_TEMP_DIRECTORY}/setup.py.in
	@ONLY)
unset(CMAKE_CUDA_COMPILER_VERSION_LIST)
unset(CMAKE_CUDA_COMPILER_VERSION_MAJOR)
unset(CMAKE_CUDA_COMPILER_VERSION_MINOR)
unset(FLAMEGPU_PYTHON_PACKAGE_DATA_OS_SPECIFIC)

file(GENERATE
	OUTPUT ${PYTHON_LIB_OUTPUT_DIRECTORY}/setup.py
	INPUT ${PYTHON_LIB_TEMP_DIRECTORY}/setup.py.in)
configure_file(
	__init__.py.in
	${PYTHON_LIB_TEMP_DIRECTORY}/__init__.py.in
	@ONLY)
file(GENERATE
	OUTPUT ${PYTHON_LIB_OUTPUT_DIRECTORY}/${PYTHON_MODULE_NAME}/__init__.py
	INPUT ${PYTHON_LIB_TEMP_DIRECTORY}/__init__.py.in)

# Function to find if python module MODULE_NAME is available, if not then install it to the Python user install directory.
function(search_python_module MODULE_NAME)
  execute_process(
    COMMAND ${Python3_EXECUTABLE} -c "import ${MODULE_NAME}; print(${MODULE_NAME}.__version__) if hasattr(${MODULE_NAME}, '__version__') else print('Unknown');"
    RESULT_VARIABLE _RESULT
    OUTPUT_VARIABLE MODULE_VERSION
    ERROR_QUIET
    OUTPUT_STRIP_TRAILING_WHITESPACE
    )
  if(${_RESULT} STREQUAL "0")
    message(STATUS "Found python module: ${MODULE_NAME} (version \"${MODULE_VERSION}\")")
  else()
    message(WARNING "Can't find python module \"${MODULE_NAME}\", user install it using pip...")
    execute_process(
      COMMAND ${Python3_EXECUTABLE} -m pip install --upgrade --user ${MODULE_NAME}
      OUTPUT_STRIP_TRAILING_WHITESPACE
      )
  endif()
endfunction()

# Look for required python modules to build the python module
# @todo - Python3.5 is no longer supported by setuptools > 51.3, so need to change the install command to reflect this in cases where pip is too old (i.e. ubuntu 16.04 on CI). It would be better to not install dependencies into non-venvs too.
# Arguably, we could set up a requirements.txt for building (and exeucting)?
# https://github.com/pypa/setuptools/issues/2541
search_python_module(setuptools)
search_python_module(wheel)

# Create the package directory before we try and copy files to it
add_custom_command(TARGET ${PYTHON_MODULE_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E make_directory "${PYTHON_LIB_OUTPUT_DIRECTORY}/${PYTHON_MODULE_NAME}/include")

# Copy the FLAMEGPU headers to a local path, this must occur before the wheel is built
add_custom_command(TARGET ${PYTHON_MODULE_NAME} POST_BUILD     # Adds a post-build event to MyTest
    COMMAND ${CMAKE_COMMAND} -E copy_directory              # which executes "cmake - E copy_directory..."
        "${ROOT}/include"                                     # <--this is in-dir
        "${PYTHON_LIB_OUTPUT_DIRECTORY}/${PYTHON_MODULE_NAME}/include" # <--this is out-dir path
    ) 


# Configure and build the python package
# The file configurations above will already have output setup.py and __init__.py to the appropriate places and created the directory for the module
add_custom_command(TARGET ${PYTHON_MODULE_NAME} POST_BUILD
# copy generated python file to library output location
COMMAND ${CMAKE_COMMAND} -E copy ${PYTHON_LIB_TEMP_DIRECTORY}/${PYTHON_MODULE_NAME}/${PYTHON_MODULE_NAME}.py ${PYTHON_MODULE_NAME}
# copy the compiled pyd file to library output location
COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${PYTHON_MODULE_NAME}> ${PYTHON_MODULE_NAME}
COMMAND ${Python3_EXECUTABLE} setup.py bdist_wheel
# by products of the packaging
BYPRODUCTS
    ${PYTHON_MODULE_NAME}
    build
    dist
    ${PYTHON_MODULE_NAME}.egg-info
    setup.py
WORKING_DIRECTORY ${PYTHON_LIB_OUTPUT_DIRECTORY}
)

# Build Virtual Environment for python testing and install the packaged wheel
if(BUILD_SWIG_PYTHON_VENV)
# Look for python module venv
search_python_module(venv)
# Testing using a virtual environment
set(VENV_EXECUTABLE ${Python3_EXECUTABLE} -m venv)
set(VENV_DIR ${PYTHON_LIB_OUTPUT_DIRECTORY}/venv)
set(VENV_BYPRODUCTS "${VENV_DIR}")
if(NOT PYTHON_LIB_OUTPUT_DIRECTORY_BYPRODUCTS)
set(VENV_BYPRODUCTS "")
endif()
if(WIN32)
    set(VENV_PIP "${VENV_DIR}\\Scripts\\pip.exe")
else()
    set(VENV_PIP ${VENV_DIR}/bin/pip)
endif()
# make a venv to install our python package in it
add_custom_command(TARGET ${PYTHON_MODULE_NAME} POST_BUILD
    # create venv
    COMMAND ${VENV_EXECUTABLE} ${VENV_DIR}
    # Install the wheel from the dist dir. Specify a version incase the same build dir has been used for a previous build 
    COMMAND ${VENV_PIP} install --force-reinstall --find-links=dist --no-index -U ${PYTHON_DISTRIBUTION_NAME}==${CDGA_VERSION_PYTHON}
    # install pytest
    COMMAND ${VENV_PIP} install pytest
    BYPRODUCTS ${VENV_BYPRODUCTS}
    # TODO: Add dependancy to ensure this post build step occurs after the previous post build step which builds the wheel
    WORKING_DIRECTORY ${PYTHON_LIB_OUTPUT_DIRECTORY})
endif()

