# Build manylinux wheels, and upload them to the build for testing within a short timeframe
name: Manylinux2014

# Run on branch push events (i.e. not tag pushes) and on pull requests
on:
  push:
    branches:
      - '**'
  pull_request:

# A single job, which builds manylinux2014 wheels, which ships with GCC 10.2.1 at the time of writing. If this bumps to unpatched 10.3 we might have issues w/ cuda. 
jobs:
  build:
    runs-on: ubuntu-20.04
    container:
      image: quay.io/pypa/manylinux2014_x86_64
    strategy:
      fail-fast: false
      matrix:
        include:
          # - python: "3.9"
          #   cuda: "11.2"
          #   cuda_arch: "52"
          # - python: "3.8"
          #   cuda: "11.2"
          #   cuda_arch: "52"
          # - python: "3.7"
            # cuda: "11.2"
            # cuda_arch: "52"
          # - python: "3.6"
            # cuda: "11.2"
            # cuda_arch: "52"

          - python: "3.8"
            cuda: "11.4"
            cuda_arch: "52"
          - python: "3.8"
            cuda: "11.3"
            cuda_arch: "52"
          - python: "3.8"
            cuda: "11.2"
            cuda_arch: "52"
          - python: "3.8"
            cuda: "11.1"
            cuda_arch: "52"
          - python: "3.8"
            cuda: "11.0"
            cuda_arch: "52"
          - python: "3.8"
            cuda: "10.2"
            cuda_arch: "52"
          - python: "3.8"
            cuda: "10.1"
            cuda_arch: "52"
          - python: "3.8"
            cuda: "10.0"
            cuda_arch: "52"
    env:
      BUILD_DIR: "build"
      CONFIG: "Release"
      BUILD_TESTS: "OFF"
      BUILD_SWIG_PYTHON: "ON"
      VISUALISATION: "OFF"

    steps:
    - uses: actions/checkout@v2

    # Install CUDA into the image.
    - name: Install CUDA (centos)
      shell: bash
      env:
        cuda: ${{ matrix.cuda }}
      run: .github/scripts/install_cuda_centos.sh

    # Configure CMake, specifying the correct python version
    - name: Configure cmake
      run: >
        cmake . -B "${{ env.BUILD_DIR }}" 
        -DCMAKE_BUILD_TYPE=${{ env.CONFIG }} 
        -DCMAKE_WARN_DEPRECATED=OFF 
        -DCUDA_ARCH="${{ matrix.cuda_arch }}" 
        -DBUILD_TESTS="${{ env.BUILD_TESTS }}" 
        -DBUILD_SWIG_PYTHON="${{ env.BUILD_SWIG_PYTHON }}"
        -DPYTHON3_EXACT_VERSION=${{ matrix.python }}

    # Build the python wheel
    - name: Build Wheel
      if: ${{ env.BUILD_SWIG_PYTHON == 'ON' }}
      working-directory: ${{ env.BUILD_DIR }}
      run: cmake --build . --target pycdga --verbose -j `nproc`

    - name: Build tests
      if: ${{ env.BUILD_TESTS == 'ON' }}
      working-directory: ${{ env.BUILD_DIR }}
      run: cmake --build . --target tests --verbose -j `nproc`

    # Run audithweel show for information, but do not repair.
    - name: Run auditwheel show
      working-directory: ${{ env.BUILD_DIR }}
      run: auditwheel show lib/${{ env.CONFIG }}/python/dist/*whl

    # Ideally we should use auditwheel repair to check/enforce conformity
    # But we cannot due to cuda shared object dependencies which we cannot/shouldnot/willnot package into the wheel. 
    # - name: Run auditwheel repair
    #   working-directory: ${{ env.BUILD_DIR }}
    #   run: auditwheel repair --plat manylinux2014_x86_64 lib/${{ env.CONFIG }}/python/dist/*whl -w wheelhouse

    # Instead, rename the wheel.
    # Wheels are not strictly manylinux complaint due to libcuda.so.
    - name: Mock auditwheel repair
      shell: bash
      run: |
        wheelhouse=${{ env.BUILD_DIR }}/wheelhouse
        mkdir -p ${wheelhouse}
        wheels_in=$(find ${{ env.BUILD_DIR }}/lib/${{ env.CONFIG }}/python/dist/ -name "*.whl")
        for wheel_path in ${wheels_in}; do
          wheel_dir=$(dirname "${wheel_path}")
          wheel_name=$(basename "${wheel_path}")
          wheel_name_out="${wheel_name//linux/manylinux2014}"
          wheel_path_out="${wheelhouse}/${wheel_name_out}"
          # Copy the wheel, renaming it
          cp ${wheel_path} ${wheel_path_out}
          echo "copied ${wheel_path} to ${wheel_path_out}"
        done

    # Rename the wheel if VISUALISATION=OFF. 
    # @todo - long term this should be handeled more gracefully within the python packaging during cmake.
    - name: Rename console-only wheels
      if: ${{ env.VISUALISATION == 'OFF' }}
      run: |
        wheelhouse=${{ env.BUILD_DIR }}/wheelhouse
        wheels_in=$(find ${wheelhouse} -name "*.whl")
        for wheel_path in ${wheels_in}; do
          wheel_dir=$(dirname "${wheel_path}")
          wheel_name=$(basename "${wheel_path}")
          wheel_name_out="${wheel_name//pycdga/pycdga-console}"
          wheel_path_out="${wheel_dir}/${wheel_name_out}"
          # Move the wheel, renaming it
          mv ${wheel_path} ${wheel_path_out}
          echo "Moved ${wheel_path} to ${wheel_path_out}"
        done

    # Upload wheel artifacts to the job on GHA, for a very short duration. This might not be desirable in practice.
    - name: Upload Wheel Artifacts
      uses: actions/upload-artifact@v2
      with:
        name: wheelhouse
        path: ${{ env.BUILD_DIR }}/wheelhouse/*.whl
        if-no-files-found: error
        retention-days: 7
